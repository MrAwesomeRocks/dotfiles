#
# WARNING: Do not edit this file.
# It was generated by processing {{ yadm.source }}
#

# clear
alias c="clear"

# clean directory
alias cleanup="/bin/rm -f *# *~"

# Directories
alias home="cd ~"
alias root="cd /"

# ls/tree
alias ll="ls -lh"
alias la="ls -Alh"
alias trea="tree -a"

# Condor
alias cq="condor_q"

# color aliases (may already exist, but ¯\_(ツ)_/¯)
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# IPython
if [[ -z $(uname -s | grep -E "(MINGW|MSYS)") ]]; then
    # Windows
    alias ipy=ipython.exe
else
    alias ipy=ipython
fi

# CPU temp
cputemp() {
    paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp) | column -s $'\t' -t | sed 's/\(.\)..$/.\1°C/'
}

# Poetry list outdated packages
poetry-outdated() {
    poetry show --outdated | grep --file=<(poetry show --tree | grep '^\w' | cut -d' ' -f1)
}

#
# git
#

{% if yadm.os == "WSL" %}

# https://github.com/microsoft/WSL/issues/4401#issuecomment-670080585
# function to check if in a windows of WSL dir
__is-windows-dir() {
    case "$PWD/" in
    /mnt/*)
        return $(true)
        ;;
    *)
        return $(false)
        ;;
    esac
}

{% else %}

# Dummy function that returns true on MSys2 and false otherwise
__is-windows-dir() {
    return $([[ "$(uname -o)" == "Msys" ]])
}

{% endif %}

git() {
    # Determine git executable for speedup in WSL
    if __is-windows-dir; then
        git_exe="git.exe"
    else
        git_exe="/usr/bin/git"
    fi

    command $git_exe $@
}

#
# apt
#
apt() {
    ## check if is sudoer
    if ! $(sudo -l &>/dev/null); then
        echo 'ERROR: root privileges are needed to run apt!'
        return 1
    fi

    cmd=$1
    shift

    case $cmd in
    ac)
        command sudo apt autoclean $@
        ;;
    autorm)
        command sudo apt autoremove $@
        ;;
    c)
        command sudo apt clean $@
        ;;
    i)
        command sudo apt install $@
        ;;
    rm)
        command sudo apt remove $@
        ;;
    up)
        command sudo apt update $@
        ;;
    upg)
        command sudo apt upgrade $@
        ;;
    *)
        command apt $cmd $@
        ;;
    esac
}

#
# tar
#
untar() {
    if [[ $# -eq 1 ]]; then
        # Detect from extension
        filename=$(basename $1)
        archive_type="${filename##*.}"
    elif [[ $# -eq 2 ]]; then
        # archive type given
        archive_type="$1"
        shift
    else
        echo "ERROR: Invlalid arguments"
        echo "Usage: untar <archive type> [directory]"
        return 1
    fi

    case $archive_type in
    gz | tgz)
        decompress_arg="z"
        ;;
    xz | txz)
        decompress_arg="J"
        ;;
    bz2 | tbz2)
        decompress_arg="j"
        ;;
    *)
        echo "ERROR: Must specify valid tar format or file."
        return 1
        ;;
    esac

    command tar -xv$decompress_arg -f $1
}

mktar() {
    if [[ $# -eq 2 ]]; then
        # archive type given
        archive_type="$1"
        shift
    else
        echo "ERROR: Invlalid arguments"
        echo "Usage: mktar [archive type] [directory]"
        return 1
    fi

    case $archive_type in
    gz | tgz)
        compress_arg="z"
        ext="gz"
        ;;
    xz | txz)
        compress_arg="J"
        ext="xz"
        ;;
    bz2 | tbz2)
        compress_arg="j"
        ext="bz2"
        ;;
    *)
        echo "ERROR: Must specify valid tar format or file."
        return 1
        ;;
    esac

    dir_name=$(basename $1)

    command tar -cv$compress_arg -f "$dir_name.tar.$ext" $dir_name
}


#
# CD
#
# https://mhoffman.github.io/2015/05/21/how-to-navigate-directories-with-the-shell.html
function cd() {
    if [ "$#" = "0" ]
    then
        pushd ${HOME} > /dev/null
    elif [ -f "${1}" ]
    then
        ${EDITOR:-nano} ${1}
    else
        pushd "$1" > /dev/null
    fi
}

function bd() {
    if [ "$#" = "0" ]
    then
        popd > /dev/null
    else
        for i in $(seq ${1})
        do
            popd > /dev/null
        done
    fi
}

# Back aliases
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ......="cd ../../../../.."
alias .......="cd ../../../../../.."
alias ........="cd ../../../../../../.."
alias .........="cd ../../../../../../../.."
alias ..........="cd ../../../../../../../../.."
alias ...........="cd ../../../../../../../../../.."
alias ............="cd ../../../../../../../../../../.."
alias .............="cd ../../../../../../../../../../../.."

#
# Checksums
#
# https://checksum.sh
function checksum() {
    local s
    s=$(curl -fsSL "$1")

    local h
    if command -v shasum >/dev/null ; then
        h=shasum
    else
        h=sha1sum
    fi

    if [ ! "$2" ] ; then
        printf %s\\n "$s" | "$h" | awk '{print $1}'
        return 1;
    fi

    printf %s\\n "$s" | "$h" --check --status <(printf '%s  -\n' "$2") || {
        echo "checksum failed" >&2;
        return 1;
    }

    printf %s\\n "$s"
}
